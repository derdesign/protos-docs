[markdown]

## Installation

    $ npm install protos

To have global access to the protos(1) executable, the framework can be installed globally:

    $ sudo npm install -g protos
    
If protos was installed locally, the protos(1) command can be run as such:

    $ ./node_modules/.bin/protos
    
> Protos runs on UNIX-like systems such as **Linux** & **Mac OSX**. Windows support might be added in the future.
    
## Creating an Application

To quickly create an application and get started:

    $ protos create myapp
    
More options can be specified to the create command:

    $ protos create myapp --domain protos.org --js jquery prototype --css bootstrap
    
An application will be created in the *myapp/* directory. Protos will automatically download the jQuery and Prototype JavaScript 
libraries, storing them *myapp/public/js* and the Bootstrap CSS framework into *myapp/public/css/bootstrap/*.

The `--domain` switch will automatically set the domain in the application's config.

To create an application with some initial models & controllers:

    $ protos create myapp --model users accounts --controller blog admin profile
    
For a full list of protos commands, run `protos --help`.

## Installing Middleware Dependencies

When installing protos, only the core dependencies are installed. Middleware dependencies are not installed. The 
`protos install` command is used to install the required middleware dependencies.

If protos detects the dependencies of a middleware are not installed, it will throw an exception including the install command
needed to get the modules installed in the application.

The application's `package.json` file is automatically updated when `protos install` is used.

To see the dependencies each middleware requires, refer to the 
[dependencies.json](https://github.com/derdesign/protos/blob/master/dependencies.json) file.

## Creating Application Resources

The protos command also allows the creation of [Controllers](#applicaton-controllers), [Helpers](#application-views_view-helpers), 
[Models](#application-models-api), [Views](#application-views) and [Partials](#view-partials).

> In order to generate components, the commands should be run within the application's path.

### Creating Controllers

Controllers are created with the `protos controller` command. This will also create the **Helpers** and **Views**:

    $ protos controller blog admin
    
To prevent helpers from being automatically created, use the `--nohelper` switch.

The generated controllers are stored in the `app/controllers` directory.

### Creating Models

Models are created with the `protos model` command.

    $ protos model posts comments
    
The model names specified will automatically be converted to their plural form.

The generated models are stored in the `app/models/` directory.
    
### Creating Helpers

Helpers are created with the `protos helper` command:

    $ protos helper navigation sidebar

The generated helpers are stored in the `app/helpers/` directory.

### Creating Views

Views are created with the `protos view` command:

    $ protos view main/info admin/accounts blog/posts,comments
    
The view command accepts several formats:

- `controller/view`
- `controller/view1,view2,view3`
- `controller/view.ext`
    
The `--ext` option can be used to create views with specific extensions:

    $ protos view main/user,test --ext jade
    
The default view extensions created by `protos view` can be specified in the following configuration option:

- `app.config.cli.viewExt`

The configuration option can be found on `config/base.js`.

The generated views are stored in the `app/views/<controler>/` directory.
  
> The view formats, configuration and options also apply to the other view generation commands.
  
### Creating View Partials

View Partials are created with the `protos partial` command, using the same format and options of views:

    $ protos partial blog/post,widget admin/sidebar
    
The generated partials are stored in the `app/views/<controller>/partials/` directory.

### Creating Static Views

Static Views are created with the `protos static` command, using the same format and options of views:

    $ protos static about contact portfolio
    
A relative path can be specified, automatically creating the necessary directories to satisfy the provided path:

    $ protos static company/info/about,pricing,support
    
The generated static views are stored in the `app/views/__static/` directory.

### Creating Restricted Views

Restricted views are created with the `protos restricted` command, using the same format and options of views:

    $ protos restricted account/login,registration
    
A relative path can be specified, automatically creating the necessary directories to satisfy the provided path.
    
The generated restricted views are stored in the `app/views/__restricted/` directory.

### Creating Layout Partials

Layout partials are created with the `protos layout` command, using the same format and options of views:

    $ protos layout site/widgets/info,popular,comments

A relative path can be specified, automatically creating the necessary directories to satisfy the provided path.

The generated layout partials are stored in the `app/views/__layout` directory.

### Downloading Client-Side Libraries (CSS/JS)

Using the `protos fetch` command, client-side assets can be downloaded, as such:

    $ protos fetch --js prototype jquery

The jQuery & Prototype.js libraries will be downloaded into the application's `public/js` directory.

CSS Libraries and Frameworks can be also be downloaded automatically, as such:

    $ protos fetch --css bootstrap blueprint
    
The Blueprint and Bootstrap CSS frameworks into the application's `public/css` directory.

The `--css` and `--js` options can be used in the same command, they are not exclusive.

For a full list of the client-side libraries provided, refer to the supported
[JavaScript Libraries](https://github.com/derdesign/protos/blob/master/client/javascript.json) and 
[CSS Frameworks](https://github.com/derdesign/protos/blob/master/client/css.json).

## Running the Application's Server

Applications can be run either by calling node directly with the application's directory (or boot file) as input,
or by using the protos executable to start the server.

### Using the node executable

To quickly start an application's server, call node with the application's directory as parameter:

    $ node myapp/
    
If located within the application's path, call the boot file directly:

    $ node boot.js
    
The application can also be launched on a specific environment:

    $ NODE_ENV=production node myapp/

### Using the protos executable

Applications can also be started using the protos command:

    $ protos server myapp/
    
If located within the application's path:

    $ protos server

Additionally, a specific environment can be specified:

    $ protos server --env production
    
The server can be run by forking into a new node process:

    $ protos server myapp/ --fork --logpath server.log
    
The server's stdout will be redirected into the log file specified.

## Protos Executable

If protos was installed globally with `npm -g install protos`, the `protos` executable is available:

    $ protos
    Usage: protos [action] [arguments]

    Actions: 

    Usage: [create, install, server, deploy, fetch, inspector, lint] 

    Components: [controller, helper, model, view, partial, layout, static, restricted]

      --domain        Domain to attach the application to (create)
      --css           Bundle client side CSS frameworks (create)
      --js            Bundle client side JavaScript libraries/frameworks (create)
      --model         Include models on application (create)
      --controller    Include controllers on application (create)
      --mustache      Use the .mustache extension for generated views (create)
      --fork          Creates a new node process when starting servers (server)
      --port          Port to use when proxying multiple servers (server)
      --env           Environment to use when running server (server)
      --logpath       File to save output when forking a new process (server)
      --nohelper      Don't create helpers when generating controllers (controller)
      --ext           Extension to use for generated normal/static/partial views (view)
      --driver        Driver to use by the model (model)
      --context       Model context to set (model)

    Example:

     $ protos create myapp --css bootstrap --js jquery backbone --model users --controller admin user

     Generate an application skeleton in the current directory, with the assets,
     models and controllers specified in the command.

     $ protos server myapp --fork --logpath server.log

     Starts the application's server and forks a new node process.

     protos@0.2.0 /usr/local/lib/node_modules/protos
     
## Deploying a Cluster Server

Protos provides a built-in proxy that will automatically direct requests for all applications. Behind the scenes,
it uses [Bouncy](https://github.com/substack/bouncy) to handle the redirection.

Applications can be deployed using the **command line** or a **JSON file**.


### Using the commmand line

Each application runs in a separate node process (or processes), isolated from other applications. Applications can specify 
how many **node processes** will be used in their respective `multiProcess` bootstrap option. 

To run a cluster server from the command line using the `app:port` convention:

    $ protos server mysite:8081 yoursite:8082 --port 80 --fork --logpath server.log --env production
    
This will run a proxy server on port 80, redirecting all requests to applications/ports specified.

### Using a JSON file

To deploy your applications using JSON, create a JSON file (preferably where the application directories live).

The **cluster.json** file has the following structure:

    {
      "fork": "true",
      "env": "production",
      "port": "80",
      "logpath": "server.log",
      "routes": {
        "mysite": "8081",
        "yoursite": "8082"
      }
    }

These settings are analogous to the command line options.

To run a cluster server using a JSON deployment file, run the following:

    $ protos deploy cluster.json
    
The JSON file can be saved with any filename.

## Running the Node Inspector

Applications can easily be debugged using [node-inspector](https://github.com/dannycoates/node-inspector).

  > Starting the application in the debug environment will automatically launch the Node Debugger.
  
To start the inspector:

    protos inspector start
    
To stop the inspector:

    protos inspector stop
    
The Node Inspector listens on http://localhost:3000

To enable debug mode in any environment, use `protos.enableDebugger()`.

## Application Structure

The following tree contains the skeletal application structure, just after running `protos create myapp`.

    myapp/
    ├── app
    │   ├── controllers
    │   │   └── main.js
    │   ├── helpers
    │   │   └── main.js
    │   ├── models
    │   │   └── users.js
    │   └── views
    │       ├── __layout
    │       │   ├── footer.html
    │       │   └── header.html
    │       ├── __restricted
    │       │   ├── 404.html
    │       │   ├── 500.html
    │       │   └── msg.html
    │       ├── __static
    │       │   └── readme.md
    │       └── main
    │           └── main-index.html
    ├── boot.js
    ├── config
    │   ├── base.js
    │   ├── drivers.js
    │   ├── env
    │   │   ├── debug.js
    │   │   ├── development.js
    │   │   └── production.js
    │   ├── regex.js
    │   └── storages.js
    ├── data
    │   └── readme.md
    ├── hooks
    │   ├── init.js
    │   └── ready.js
    ├── incoming
    │   └── readme.md
    ├── lib
    │   └── application.js
    ├── log
    ├── middleware
    │   └── readme.md
    ├── package.json
    ├── public
    │   ├── favicon.ico
    │   └── robots.txt
    ├── scripts
    │   └── sample.js
    └── test
        └── readme.md

### boot.js

The Application's [bootstrap](#the-applications-bootstrap-file-bootjs) file. It is used to specify the 
initial configuration, and many other important options.

### package.json

Package & Dependency information for the application.

### app/

Stores the application logic:

- **controllers**: controller files
- **helpers**: helper files
- **models**: model files
- **views**: view & layout files

### app/views

Directory where all the views are stored

- **__layout**: layout partials
- **__restricted**: restricted views
- **__static**: static views

Any other directories not mentioned (and present in the directory) are reserved for controller views.

### app/views/<controller>

Directory in which the views for <controller> are stored.

### config/

Application's configuration files. For more information, refer to [Application Configuration](#application-configuration).

### config/env/

Directory containing the environment-specific init scripts.

### data/

Any kind of data used by the application. Included for convenience purposes.

### hooks/

Directory used to store the application hooks (event handlers).

### incoming/

Directory to store file uploads. This is the upload location for the [Body Parser Middleware](middleware.html#body_parser).

### lib/

Application library files. Included for convenience purposes.

### log/

Directory used to store log files. This is the storage location for the [Logger Middleware](middleware.html#logger).

### middleware/

Application-specific middleware.

### public/

Public directory used to serve static content.

### scripts/

Miscellaneous scripts.

### test/

Application test files. Included for convenience purposes.


## Application Configuration

The application can be configured by editing the **bootstrap** file (boot.js), or by modifying the **configuration files**.

### Configuration Files

The configuration files are stored in the config/ directory. Here's an explanation on what each file contains:

- **base.js**: Base application configuration, directly accessed via `app.config`
- **drivers.js**: Driver configuration settings.
- **regex.js**: Regular Expressions to be used by the application
- **storages.js**: Storage configuration settings
- **env/**: Holds scripts for each environment

> Each file added into the config/ directory, will be added as a property of the `app.config` object.

### Driver & Storage Configuration

Each property in the configuration object belongs to the driver being configured:

    {
      default: 'mongodb',
      mongodb: {
        host: 'localhost',
        port: 27017
      }
    }
    
This approach assumes that the driver has only one configuration.  A driver can also have multiple configurations:

    {
      default: 'mongodb:users',
      mongodb: {
        users: {
          host: 'users.host.com',
          port: 27017
        },
        clients: {
          host: 'clients.host.com,
          port: 27017
        }
      }
    }
    
## Driver & Storage Resource Paths

There are some situations in which you need to specify a _resource path_. Resource Paths only apply to Drivers and Storages, and 
is a method to access a specific driver or storage with a specific configuration.

If the driver has only one configuration, it can be used by just specifying its name, such as `mongodb` or `postgres`. The 
driver name is a driver provided by protos in `lib/drivers`.

If there are multiple configurations for the driver, it can be used by specifying the driver name, and the respective configuration,
separated by a colon, as such: `mongodb:users` or `postgres:accounts`.

> **Resource Paths** are used by models to detect the underlying driver configuration.

## The Application's Bootstrap File (boot.js)

This file is used to start the application. It is provided by the application skeleton:

    var Protos = require('../');

    Protos.bootstrap(__dirname, {
  
      // Application configuration
      debugLog: false,
  
      // Server configuration
      server: {
        host: 'localhost',
        port: 8080,
        multiProcess: false,
        stayUp: 'production'
      },
  
      // Application environments
      environments: {
        default: 'development',
        development: function(app) { 
          // Development environment code
        }
      },
  
      // Application events
      events: {
        components: function(protos) {
          // Load framework components
          protos.loadDrivers();
          protos.loadStorages();
          protos.loadEngines('ejs');
        },
        pre_init: function(app) {
          // Pre-initialization code
        },
        init: function(app) {
          // Load middleware
          app.use('logger');
        }
      }
  
    });

    module.exports = protos.app;

### Application Configuration

- **debugLog** &nbsp; _If set to true, will print debugging messages to stdout._

### Server Configuration

- **host** &nbsp; _Hostname to bind your application to._
- **port** &nbsp; *Port your app will listen. Might get overidden on deployment or by the `PORT_OVERRIDE` env.*
- **multiProcess** &nbsp; *Node processes the application will use. If `true` will use all available cores.*
- **stayUp** &nbsp; *Whether or not the server should exit on exceptions. If `true` will enable for all environments. An environment
name will enable the feature on that environment. An array of environments can also be used.*

### Application Environments

- **default** &nbsp; *Environment to use when running the application without specifying an environment.*
- **development** &nbsp; *Function to call when running on the `development` environment.*
- **production** &nbsp; *Function to call when running on the `production` environment.*
- **&lt;environment&gt;** &nbsp; *Run code for any environment by specifying a function and its name.*

### Application Events

- **init** &nbsp; *Function to call when the application initializes*
- **&lt;event&gt;** &nbsp; *Run code for an event by specifying a function and the event name*

## Application Controllers

Each controller groups routes for specific _namespaces_. For example:

- **BlogController**: _groups routes for the blog/ namespace_
- **AdminController**: _groups routes for the admin/ namespace_
- **UserController** _groups routes for the user/ namespace_
- **UserGroupController** _groups routes for the user-group/ namespace_

Each controller can have filters, which are functions run before each request is run. Are also used to encapsulate 
authentication for the contained routes.

> The namespace refers to the first section of the request URL, for example: `myapp.com/namespace/action/arg`


### MainController

This is a special controller, and is used to group all general routes not belonging to a specific namespace. By default, it
is the only controller included in the application skeleton, since it is required.

## Routes

Routes define the application's URL structure. Each route is defined **relative** to the its namespace.

### Route Functions

Routes map directly to HTTP Methods, such as GET, POST, PUT, DELETE, OPTIONS, TRACE. 

The functions are exposed as **pseudo-globals** (can be accessed without being defined inside the controller, but are not global), and are
defined as the method name, in lowercase.

### Route Function Arguments

The route functions can receive various types of arguments:

    get(route, validation, callback1, callback2, method1, method2);

- **route (string)** _the route to bind, including named parameters (prefixed with colons)_
- **validation (object)** _an object containing route parameters and their validation (regex, alias or function)._
- **callback (function)** _route callback(s) used to handle the request. Multiple can be specified sequentially._
- **method (string)** _additional method(s) to be handled by the route. Multiple can be specified sequentially._

The `validation` and `method` arguments are optional. Multiple callbacks can also be specified (additionally supporting an 
array of callbacks). At least one route `callback` is required.

### Simple Routes

A simple route is one that only has _(route, callback)_, such as:

    get('/hello', function(req, res) {
      res.render('index');
    });
    
If the route is placed in **MainController**, it will be bound to the global `/hello` URL. If it's
bound in any other controller, then it will be bound to the `/<namespace>/hello` URL.
    
### Multiple Route Callbacks

Multiple callbacks can be assigned to a specific route. Each will be executed in turn, passing control to the next
callback in the queue. All callbacks are invoked with `(req, res, params)` as arguments:

To pass control to the next callback, use `req.next()`.

Any callback in the queue can send a response (in this case, passing control to the next callback is not necessary).

### Route Validation & Regular Expressions

Protos implements a route validator, which uses Regular Expressions and functions to validate the routes.

Routes can use named parameters, which in turn require specific validation in order for the route to match:

    get('/user/:name/:action' {name: 'alpha_underscores', action: /^(manage|show|delete)$/}, function(req, res) {
      ...
    });
    
The route has the `:name` and `:action` paramters, which are validated by the validation object.

The validation object can receive the following:

- **Regular Expression Literal**: _any regular expression._
- **Regular Expression Alias (string)** _any named regular expression provided by the app or protos._
- **Function**: _A validation function, invoked with the value to be validated. Returns boolean._

> The route validator applies the validation to each **chunk** (separated by the slashes) individually, providing the
> flexibility to match specific portions of the route with functions and/or individual RegExps.

If a URL matches the route, the `req.params` object will contain the named route parameters with their respective values.

### Accessing GET Query Data

The Query String data from the URL can be accessed via the `req.queryData` object.

Additionally, the Query String data can be obtained using the `req.getQueryData` method. If the [CSRF Middleware](/middleware.html#csrf)
is enabled, you can validate the CSRF token, and only accept the data if a valid token has been provided:

    req.getQueryData('secure', function(fields) {
      ...
    });
    
In this case, the query data will only be accessed if a valid token was specified. If not, an HTTP/400 response will be sent.

The 'secure' token has been generated with `req.csrfToken('secure')` in a template. For more info about tokens and CSRF in
general, consult the [CSRF Middleware](/middleware.html#csrf) documentation.

Using `req.getQueryData` without a CSRF token will invoke the callback with the `req.queryData` object, as if it had been
accessed directly.


### Accessing POST/PUT Fields & Files

To be able to parse the POST/PUT Request Bodies, the [Body Parser](/middleware.html#body_parser) middleware is required.

The middleware provides the `req.getRequestData` method, which is used to obtain the request fields and any uploaded files in
the request:

    req.getRequestData(function(fields, files) {
      ...
    });

The `files` argument is a [FileManager](/middleware.html#body_parser_filemanager-class) instance, which is used to manipulate
any uploaded files. If not expecting any files, use `files.removeAll()` to remove any uploaded files in the request.

If the [CSRF Middleware](/middleware.html#csrf) is enabled, the CSRF token can be provided. In this case, the callback will only 
be invoked if the token provided is valid. Otherwise, an HTTP/400 response is sent.
    
    req.getRequestData('secure', function(fields, files) {
      ...
    });

### Using the Validator

Protos implements a powerful **Validator** class, used to perfom all sorts of validation. A validator object groups several
validation rules and can be reused to validate data several times.

A new Validator instance can be obtained as such:

    var validator = app.validator();
  
The validator object accepts the following validation mechanisms:

- **RegExp Literal** any regular expression
- **RegExp Alias** any regular expression alias defined in the application
- **Function** a function invoked with the value to validate, which returns true if valid

> The job of the Validator is to receive an object to validate. Returns an **error message** on failure, and `null`
> on success.

The Validator allows **optional values**, which don't raise an error if not present on the object to validate.

The example below shows how to add validation rules to the Validator object:

    var validator = app.validator()
      .add({name: 'alpha'}, "Invalid name: %s")
      .add({email: 'email'}, "Invalid email: %s")
      .addOptional({password: 'password', password_confirm: 'password'}, "The password is invalid")
    
In this case, the `name`, `email`, `password` and `password_confirm` fields will be validated. The last two being optional.

As can be seen, the Validator methods can be chained, since each return the Validator instance. Also, multiple validation
fields can be defined in a single rule (as is the case with the password), sharing the same error message.

The validation error message can include the `%s` placeholder, which will be replaced with the invalid string.

To use the newly created validator:

    var err = validator.validate({
      name: "Ernie",
      email: "email@domain.com",
      password: "abc" // too short
    });
    
In this case, the validator will return the error message defined for password:

    "The password is invalid"
    
If the validation object contains fields that are determined to be valid, the validator will return `null`. Additionally, it
will **remove** any fields not defined in the validation rules from the _object being validated_.

The validator can also filter values after they have been validated. This is useful in case the data needs to be processed after
it has been validated. This is done using the `filter` method of the Validator:

    var validator = app.validator().
      .add({value: 'alpha'}, "Invalid value")
      .filter({
        value: function(val) {
          return new Buffer(val.trim().toUpperCase()).toString('base64');
        }
      });
      
In this case, whenever the `value` field is validated, it will be automatically processed by the filter, returning a base64
encoded string of its uppercase & trimmed contents.

The object being validated is automatically modified by the Validator. This way (if the validation is successful) when accessing
the object again, it will only contain the validated (and filtered, if any filters are present) fields. Any other fields not present
in the validation rules will be deleted from the object.

> The **Validator** can be used to validate both **GET Query Data** and **POST/PUT fields** after these have been obtained.

## Controller Authentication & Filters
 
Controller filters add an additional _authentication layer_ to your Controllers. By analyzing the _request_ and _response_
objects, you can determine whether or not the user is allowed to access the controller's resources.

Let's say we have the following Controller:

    function MainController(app) {
      
      get('/', function(req, res) {
        res.end("WELCOME!");
      });

      get('/:page', {page: 'alpha'}, function(req, res, params) {
        res.json(params);
      });
      
    }
    
This will respond with _"WELCOME"_ when accessing _/_, and will send a JSON response when a regular page is accessed. We'll 
implement a very basic authentication, using a GET parameter called `pass` using a _Filter_.

This is the controller code, after the filter has been implemented:

    function MainController(app) {
  
      this.filter(function(req, res, promise) {
        if (req.queryData.pass === '1234') promise.emit('success');
        else res.rawHttpMessage(403, true);
      });
  
      get('/', function(req, res) {
        res.end("WELCOME!");
      });
  
      get('/:page', {page: 'alpha'}, function(req, res, params) {
        res.json(params);
      });
  
    }
    
Now, if you try to access any of your controller's resources without providing the `pass` query parameter, you will not be
able to access the routes, and will be responded with a `403 Forbidden` message.

In this case, we're using `req.queryData.pass` to get the `pass` query parameter, we're not doing any validation on it, just 
getting it right as it was received. If you need validation, then `this.getQueryData` should be used.

The Authentication Filters run before any Route Functions are executed. Have this in mind when designing your Applications.

### Implementation Details

There are a few important things to know about Controller Filters to be able to use them at full potential:

- You add them by doing `this.filter(callback)` from within any controller
- A Controller can have multiple authentication filters by running `this.filter` multiple times.
- The _Filter Callback_ runs in the _Controller's Context_
- The _Filter Callback_ receives three parameters:  _request_, _response_ and _promise_
- If validation succeeded, you emit the `success` event on the promise
- If validation fails, you need to send a response manually

### Filters & Sessions

When using the [Sessions Middleware](middleware.html#session), it automatically provides a authentication filter for you, which
deeply integrates with both the controller and your application.

If/when you enable the _Sessions Middleware_, you can specify a property in your controllers, to determine
if such controller requires authentication: the `authRequired` property.

### The authRequired property

This only applies if the _Sessions Middleware_ is enabled. It has no effect otherwise.<br/>
For a detailed documentation on this property, refer to the _Sessions Middleware_ [documentation](middleware.html#session).


## Application Views

This section covers everything you need to know about views. Views are rendered by calling `res.render` from of your
_Route Callbacks_. The view paths will be resolved depending on the _view_ specified, as well as the running _Controller_.

### View Lookup

It is important to master the view lookup process to be able to use views at their full potential. The table below shows the 
argument passed to `res.render`, and the corresponding resolved path. 

In the table below: 

- The controller is assumed to be _MainController_. View paths are relative to _app/views/_.
- The view extensions are automatically detected, unless manually specified.

You can see how views are used by having a look at the Controllers from the [Test Suite](https://github.com/derdesign/protos/tree/master/test/fixtures/test.skeleton/app/controllers).

### View Parameters

When rendering views with `res.render`, you can pass extra parameters to the view. For example:

    res.render('index', {
      activePage: 'features',
      message: "Hello World!"
    });
    
These parameters will be available as locals within the view.

### View Locals

When rendering views, you have a set of _local variables_ you have access to inside views:

- **protos** &nbsp; _Protos global (available as local)_
- **app** &nbsp; _Application singleton_
- **req** &nbsp; _Request Object_
- **res** &nbsp; _Response Object_
- **params** &nbsp; _Pointer to `req.params`_
- **session** &nbsp; _Pointer to `req.session`_
- **cookies** &nbsp; _Pointer to `req.cookies`_
- **locals** &nbsp; _View locals object (circular reference)_

### Raw Views

Protos introduces the concept of _Raw Views_, to the views that don't render a header/footer. These are still rendered in
`text/html`, but only the requested view is rendered, not the other template parts.

> By default, the Application has _Raw Views_ disabled. You can enable _Raw Views_ globally within your application, by
> editing **config/base.js** and setting `rawViews` to true.

The _raw_ parameter is passed to `res.render` as a boolean in its last argument:

    res.render('index', {
      activePage: 'features',
      message: "Hello World!"
    }, true);
    
There are some template engines that force _Raw Views_, due to their inner workings. These are:

- Haml
- Haml-Coffee
- Jade

If you're using any of these Template Engines, then the templates won't be _MultiPart_. In other words, you will need to
do the templating and inclusion of header/footer and other parts from within the view itself. You can still use view
partials normally.
    
### View Extensions

The following table shows the view extensions for each Template Engine:

<table>
<thead>
<tr>
<th></th>
<th> Template Engine </th>
<th>  Engine Alias </th>
<th> View Extensions </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> CoffeeKup </td>
<td> coffeekup </td>
<td> coffeekup, ck.html</td>
</tr>
<tr>
<td></td>
<td> DoT </td>
<td> dot </td>
<td> dot, dot.html</td>
</tr>
<tr>
<td></td>
<td> Eco </td>
<td> eco </td>
<td> eco, eco.html</td>
</tr>
<tr>
<td></td>
<td> EJS </td>
<td> ejs </td>
<td> ejs, ejs.html</td>
</tr>
<tr>
<td></td>
<td> Haml </td>
<td> haml </td>
<td> haml, haml.html</td>
</tr>
<tr>
<td></td>
<td> Haml-Coffee </td>
<td> hamlcoffee </td>
<td> hamlc, haml.coffee, hamlc.html</td>
</tr>
<tr>
<td></td>
<td> Handlebars </td>
<td> handlebars </td>
<td> handlebars, handlebars.html, hb.html</td>
</tr>
<tr>
<td></td>
<td> Hogan.js </td>
<td> hogan </td>
<td> hogan, hogan.html, hg.html</td>
</tr>
<tr>
<td></td>
<td> Jade </td>
<td> jade </td>
<td> jade, jade.html</td>
</tr>
<tr>
<td></td>
<td> Jazz </td>
<td> jazz </td>
<td> jazz, jazz.html</td>
</tr>
<tr>
<td></td>
<td> jQuery Templates </td>
<td> jqtpl </td>
<td> jqtpl, jqtpl.html, jq.html</td>
</tr>
<tr>
<td></td>
<td> JSHtml </td>
<td> jshtml </td>
<td> jshtml</td>
</tr>
<tr>
<td></td>
<td> Kernel </td>
<td> kernel </td>
<td> kernel, kernel.html, k.html, khtml</td>
</tr>
<tr>
<td></td>
<td> Liquor </td>
<td> liquor </td>
<td> liquor, liquor.html, lq.html</td>
</tr>
<tr>
<td></td>
<td> Swig </td>
<td> swig </td>
<td> swig, swig.html, sw.html</td>
</tr>
<tr>
<td></td>
<td> Whiskers </td>
<td> whiskers </td>
<td> whiskers, whiskers.html, wk.html</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

  > You can edit and set new extensions by editing your Application's **config/base.js**, under the _engines_ section. Each
  > property you set will refer to the engine extension, and the value is the _Engine Alias_.


### Static Views

You can create routes in your application without actually creating them in Controllers. You can also place a file in the 
*app/views/__static* directory.

Let's say your application should handle the following URLs, which mostly contain static content:

    http://myapp.com/portfolio
    http://myapp.com/about

If you want to keep your routes clean, you don't need to add a simple route to handle these. Just create the following files:

    app/views/__static/portfolio.html
    app/views/__static/about.html
    
Each time you access the URLs above, these templates will be used.

## View Partials

View Partials are one of the beauties of Protos. You can mix & match any view engine. Your application doesn't actually
care which template engine you use, you can still use partials.

One thing to have in mind, your template's rendering engines will work just fine. This section covers the _View Partials_, as
implemented across all the view engines within Protos.

Important things to know about view partials:

- Are exposed as local functions within your views
- Can be located anywhere within the *__layout* directory path
- Are located within the *partials/* directory, directly inside the view path
- The view extension determines the template engine to be used
- Partial functions *should* receive a *locals* object as argument

To learn to create view partials, refer to the [Creating View Partials](#creating-application-resources_creating-view-partials) section.

  > The View Partials are exposed as local functions within your views. Most views allow running regular JavaScript functions and
  > receiving parameters passed as their _locals_. Protos uses this common approach and exploits its full potential.

### Automatic Watching for Changes

On all environments except **production**, the framework re-compiles the view partial functions whenever any changes are made to the template files.

### Exposed Functions

The table below shows the location and the explosed function name. Paths are relative to _app/views_.

<table>
<thead>
<tr>
<th></th>
<th> View Partial File </th>
<th> Exposed View Function </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> main/partials/partial.html </td>
<td> main_partial</td>
</tr>
<tr>
<td></td>
<td> __layout/sidebar.html </td>
<td> layout_sidebar</td>
</tr>
<tr>
<td></td>
<td> __layout/widget/rss.html </td>
<td> layout_widget_rss</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

To render a view partial inside a view, just call the function. The following example uses the Liquor engine to import a view
partial into the view:

    <div class="post-comment">
      <%- blog_post_comment(locals.comments) %>;
    </div><!-- .post-comment -->


## View Helpers

View helpers are also functions that are exposed into the views. They are similar in functionality to view partials, but
they end up in the views in a slightly different way.

  > View Helpers are generated from the Methods of the Helpers defined in your Application.

Let's say you have created the following _Helpers_ in your Application:

&bull; _app/helpers/main.js_

    function MainHelper(app) {
  
      this.hello_world = function(data) {
        return JSON.stringify(data);
      }
      
    }

&bull; _app/helpers/accounts.js_

    function AccountsHelper(app) {
      
      this.show_info = function(data) {
        return JSON.stringify(data);
      }
      
    }
    
&bull; _app/helpers/dashboard.js_
    
    function DashboardHelper(app) {
      
      this.render_widget = function(data) {
        return JSON.stringify(data);
      }
      
    }

Then, your views will have the following methods exposed:

- `$hello_world`
- `$accounts_show_info`
- `$dashboard_render_widget`

The following are important things to know about View Helpers:

- Are added into the views from the _Helper Methods_ defined in your Application
- The methods exposed by _MainHelper_ are not prefixed
- The methods exposed by the other helpers are prefixed with the _helper alias_

### Default View Helpers

The framework provides a default set of helpers you can use:

- **$sanitize**: _Sanitizes input_
- **$escape**: _Escapes input_
- **$safestr**: _Sanitizes & Escapes input_

### Accessing View Helpers

All of the application's helpers can be accessed via the `app.helpers` object, using the helper alias. Also, 
helpers can be accessed using alias properties in the Application's singleton. For example:

- `app.helpers.main` &raquo; `app.mainHelper`
- `app.helpers.utils` &raquo; `app.utilsHelper`
- `app.helpers.custom-stuff` &raquo; `app.customStuffHelper`


## Application Models & API

Models provide an abstraction of data operations. Protos Models have _ORM_ built-in. They are _database-agnostic_ by nature, which
means you can define your data structure in the model, and you don't need to care about the underlying database.

Models use Drivers behind the scenes to perform database operations. The Drivers themselves perform low-level operations in the
database to manipulate the model's data.

### Defining the Driver

Each model needs a driver. Models by default inherit the _default_ driver, configured in _config/database.js_.

To connect the model with a Driver, you need to provide the Driver's _resource path_:

    this.driver = 'mongodb:users'
    
For more info on _resource paths_, please refer to the [Application Configuration](#application-configuration) section.

### Defining Properties

The model's properties defines is structure and data types. These are used for _automatic typecasting_ and _validation_ purposes.

The `properties` property defines the model's information. Here's how you set it up:

    this.properties = {
      user    : {type: 'string', required: true, validates: 'alnum_underscores'},
      pass    : {type: 'string', required: true, validates: 'password'},
      friends : {type: 'integer', validates: 'integer', default: 0},
      valid   : {type: 'boolean', default: true},
      date    : {type: 'timestamp', validates: 'timestamp', default: function() { return new Date(); }},
      object  : {type: 'object', default: {a: 1, b: 2, c: 3}},
      array   : {type: 'array', default: [1,2,3,4]}
    }
    
The following table explains the different keywords:

<table>
<thead>
<tr>
<th></th>
<th> Property </th>
<th> Description </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> <strong>type</strong>     </td>
<td> Type of data. Available types are: (string|integer|boolean|timestamp|object|array)</td>
</tr>
<tr>
<td></td>
<td> <strong>required</strong> </td>
<td> Whether or not  the field is required</td>
</tr>
<tr>
<td></td>
<td> <strong>validates</strong> </td>
<td> Regular Expression or Alias used to validate the property</td>
</tr>
<tr>
<td></td>
<td> <strong>default</strong> </td>
<td> Sets the default value for the property. Accepts both values & functions</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

  > The model will automatically typecast values to their respective JavasCript Native Objects.
  
One of the most powerful things about Protos's model implementation, are the _Object Types_. You can safely store _JavaSript
Hashes_ and _Arrays_ into model properties.

The _type_ keyword will define how the data will be typecasted. You still need to set validation rules, since validation is
a separate process.

When validating, here's how the framework knows which Regular Expression to use:

1. RegExp Literal
2. Model-Specific Validation
3. Application Regular Expression Alias

### Defining Validation

The Model Validation uses the same approach as [Route Validation](#routes). It will use the Regular Expressions defined 
by the application. Any _Regular Expression Alias_ can be used to validate fields.

There is an extra layer of validation provided by models: the `validation` property, which defines
Model-Specific validation rules. Imagine it as _Regular Expression Aliases_ that are only avaliable to the model.

Here's how you define the validation in a model:

    this.validation = {
      'account': function(str) {
        return checkAccount(str);
      },
      'username: /^(ernie|james)$/
    }

You can then use these validation aliases freely to validate your model's properties. Defining validation for the model is optional,
you can either use RegExp Literals, or the Applications' Regular Expressions.
    
### The Model API

The table below shows the Methods provided by all Model instances:

<table>
<thead>
<tr>
<th></th>
<th> Method </th>
<th> Parameters </th>
<th> Function </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> new &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </td>
<td> o, cdata, callback &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </td>
<td> Creates a new model object. Saves into the database, then creates the model with the provided data.</td>
</tr>
<tr>
<td></td>
<td> create </td>
<td> o, cdata, callback </td>
<td> Alias of <em>new</em></td>
</tr>
<tr>
<td></td>
<td> insert </td>
<td> o, cdata, callback </td>
<td> Same behavior as new, but instead of returning a new object, returns the ID for the new database entry.</td>
</tr>
<tr>
<td></td>
<td> add </td>
<td> o, cdata, callback </td>
<td> Alias of <em>insert</em></td>
</tr>
<tr>
<td></td>
<td> get </td>
<td> o, cdata, callback </td>
<td> Gets an new model object.</td>
</tr>
<tr>
<td></td>
<td> find </td>
<td> o, cdata, callback </td>
<td> Alias of <em>get</em></td>
</tr>
<tr>
<td></td>
<td> getAll </td>
<td> o, cdata, callback </td>
<td> Gets all records from the database</td>
</tr>
<tr>
<td></td>
<td> findAll </td>
<td> o, cdata, callback </td>
<td> Alias of <em>getAll</em></td>
</tr>
<tr>
<td></td>
<td> save </td>
<td> o, cdata, callback </td>
<td> Saves the model data into the Database.</td>
</tr>
<tr>
<td></td>
<td> update </td>
<td> o, cdata, callback </td>
<td> Alias of <em>save</em></td>
</tr>
<tr>
<td></td>
<td> delete </td>
<td> o, cdata, callback </td>
<td> Deletes the model data from the database.</td>
</tr>
<tr>
<td></td>
<td> destroy </td>
<td> o, cdata, callback </td>
<td> Alias of <em>delete</em></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

Here's the meaning of the Parameters:

- **o** &nbsp; _Object containing the model properties to query_
- **cdata** &nbsp; _[Cache Data](#database-drivers_cache-keywords) to pass to the driver: [ cacheID, cacheInvalidate, cacheTimeout ]_
- **callback** &nbsp; _Callback to call upon completion_

### Application's Model Methods

Models can be accessed in several ways. All models expose things in a similar way, so explaining with a single model would
be enough to understand the concept. For the sake of this example, we'll assume _UsersModel_.

The _UsersModel_ instance can be accessed via `app.usersModel` and `app.models.usersModel`. Each model instance has the methods
documented in the previous section.

The table below shows the model methods and their equivalent:

<table>
<thead>
<tr>
<th></th>
<th> Method </th>
<th>  Equivalent </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> app.model.newUser </td>
<td> app.usersModel.new</td>
</tr>
<tr>
<td></td>
<td> app.model.createUser </td>
<td> app.usersModel.create</td>
</tr>
<tr>
<td></td>
<td> app.model.insertUser </td>
<td> app.usersModel.insert</td>
</tr>
<tr>
<td></td>
<td> app.model.addUser </td>
<td> app.usersModel.add</td>
</tr>
<tr>
<td></td>
<td> app.model.getUser </td>
<td> app.usersModel.get</td>
</tr>
<tr>
<td></td>
<td> app.model.findUser </td>
<td> app.usersModel.find</td>
</tr>
<tr>
<td></td>
<td> app.model.findAllUsers </td>
<td> app.usersModel.findAll</td>
</tr>
<tr>
<td></td>
<td> app.model.saveUser </td>
<td> app.usersModel.save</td>
</tr>
<tr>
<td></td>
<td> app.model.updateUser </td>
<td> app.usersModel.update</td>
</tr>
<tr>
<td></td>
<td> app.model.deleteUser </td>
<td> app.usersModel.delete</td>
</tr>
<tr>
<td></td>
<td> app.model.destroyUser </td>
<td> app.usersModel.destroy</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>


### The Model Generator Concept

Protos introduces the _"Model Generator"_ concept. In JavaScript & Node.js, most callbacks are asynchronous. This makes the
usual ORM approach to create an object and _then_ synchronously saving its settings is not that intuitive with most database 
modules running asynchronously.

Each _Model Instance_ is itself a _Model Generator_. The term can also be interchangeable with _Model Factory_.

The Model Object does not operate directly on model objects. _Model Objects_ (introduced on the next section) use the methods
provided by the Model API, to perform the CRUD operations.

  > Model Generators are used to retrieve a group of_ Models Objects_. The returned objects will be directly related to the parameters
  > you pass to the Model Generator's method.

The term exists to make a _distinction_ between the object that _generates_, and the object that is _generated_.

### The Model Object Concept

Model Objects are individually retrieved by _Model Generators_. They contain a set of methods totally different from the ones
found in the _Model Generator_.

  > Relationships defined in Models expose their own methods into the Model Objects created by the Models
  
The sections below will explain in detail which methods are exposed by each relationship. If multiple relationships are set 
on the model (either _Inbound_ or _Outbound_), their specific methods will end up in the Model Object.

You can access the Model Object's prototype via the `modelObjectProto` on the Model Instance. In this case, the term "Model" refers
to the _Model Generator_. The object is itself bound to the `__proto__` property of all model instances. The real prototype is 
found on `modelObjectProto.constructor.prototype`.

Each Model Object as a `generator` property, which points to the _Model Generator_ that created it.

Model Objects are analogous to the models you see in other Application Frameworks or ORM Implementations. The following table
shows the Methods provided by the Model Object's _Prototype_:

<table>
<thead>
<tr>
<th></th>
<th> Method </th>
<th> Arguments </th>
<th> Description </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> save </td>
<td> cdata, callback </td>
<td> Saves the model data</td>
</tr>
<tr>
<td></td>
<td> update </td>
<td> cdata, callback </td>
<td> Alias of <em>save</em></td>
</tr>
<tr>
<td></td>
<td> sync </td>
<td> cdata, callback </td>
<td> Alias of <em>save</em> </td>
</tr>
<tr>
<td></td>
<td> delete </td>
<td> cdata, callback </td>
<td> Removes model</td>
</tr>
<tr>
<td></td>
<td> remove </td>
<td> cdata, callback </td>
<td> Alias of <em>delete</em></td>
</tr>
<tr>
<td></td>
<td> destroy </td>
<td> cdata, callback </td>
<td> Alias of <em>delete</em></td>
</tr>
<tr>
<td></td>
<td> createMulti </td>
<td> options </td>
<td> Creates a multi-wrapped object from Model Object</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

Here's the meaning of the Parameters:

- **cdata** &nbsp; _[Cache Data](#database-drivers_cache-keywords) to pass to the driver: [ cacheID, cacheInvalidate, cacheTimeout ]_
- **callback** &nbsp; _Callback to call upon completion_
- **options** &nbsp; _Options to pass to the Multi constructor_

### Query Caching

Models inherit query caching because they have a Driver under the hood. This means that they automatically receive the 
caching functionality. 100% Free.

### Model Relationships

Protos implements relationships between models. Relationships allow _Model Objects_ to connect with other model objects, adding
the additional ability to perform actions on such relationships.

Relationships only affect _Model Objects_. Each relationship, depending if it is _Inbound_ or _Outbound_, will modify either
the source or the destination model.

  > The Relationships implementation makes use of **Linguistic Inflection**, so the names should be specified in a specific form, either
  > _plural_ or _singular_ depending on the relationship being established.

An **Inbound** Relationship is where the _source_ model is the target receiving the link to the _destination_ model.

An **Outbound** Relationship is where the _destination_ model is the target receiving the link to the _source_ model.

The sections below explain the relationships, and their specific requirements and exposed methods.
 
### hasOne Relationship

This is an _Inbound_ relationship, affecting the model which establishes the connection. This relationship consists on the following:

  > The model establishing a connection, receives a one-to-one connection with the target model. A _string_ property will be assigned into the
  > Model Generator, which will define the link to the destination model.

Here's how you set a _hasOne_ relationship:

    this.hasOne = 'user';
    
The target model _must_ be specified in _singular form_. This relationship will set a `user` property into the _Model Generator_, which
links to a _Model Object_ of _UsersModel_.

Additionally, you can set the relationship to an _alias_ of the target model. This allows you to use a different property other
than the singular form of the target model:

    this.hasOne = 'buddy(user)';
    
This will set a `buddy` property into the _Model Generator_, which links to a _Model Object_ of _UsersModel_.

Based on the property assigned, the _Model Object_'s prototype will be extended with new methods. The following table outlines
the inherited methods on the _Model Object_ establishing the relationship. A property of `user` is assumed to be added:

<table>
<thead>
<tr>
<th></th>
<th> Method </th>
<th> Arguments&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </th>
<th> Provides </th>
<th> Description </th>
<th>  </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> getUser </td>
<td> callback </td>
<td> err, model </td>
<td> Gets the linked model</td>
<td></td>
</tr>
<tr>
<td></td>
<td> setUser </td>
<td> model/id, callback </td>
<td> err </td>
<td> Links model to self</td>
<td></td>
</tr>
<tr>
<td></td>
<td> removeUser </td>
<td> callback </td>
<td> err </td>
<td> Breaks the relationship with model</td>
<td></td>
</tr>
<tr>
<td></td>
<td> deepRemoveUser </td>
<td> callback </td>
<td> err </td>
<td> Breaks relationship with model and deletes the unlinked model from database</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

Assuming _AccountsModel_ has set the relationship, the following example shows how to use the relationship:

    app.model.getAccount({id: 99}, function(err, account) {
      account.deepRemoveUser(function(err) {
        if (err) throw err;
        else console.exit("Successfully unlinked & removed user from account"); // Account now has no user linked
      });
    });

### hasMany Relationship

This is an _Inbound_ relationship, affecting the model which establishes the connection. This relationship consists on the following:

The model establishing the connection receives a one-to-many connection with the target model. An _array_ property will be assigned
into the Model Generator, which will define the links to the destination model.

Here's how you set a _hasMany_ relationship:

    this.hasMany = 'users';
    
You can also specify an array of target models:

    this.hasMany = ['groups', 'buddies(users)']
    
Aliases work exactly the same for this relationship as well. The only difference is that _plural form_ must be used to define the target models.

The example above will set a `groups` array property into the _Model Generator_, which contains links to _Model Objects_ of _GroupsModel_. Additionally,
a `users` property will be added, containing links to _Model Objects_ of _UsersModel_.

Based on the property assigned, the _Model Object_'s prototype will be extended with new methods. The following table outlines
the inherited methods on the _Model Object_ establishing the relationship. A property of `buddies` is assumed to be added:

<table>
<thead>
<tr>
<th></th>
<th> Method </th>
<th> Arguments&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </th>
<th> Provides&nbsp;&nbsp;&nbsp;&nbsp; </th>
<th> Description </th>
<th>  </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> addBuddy </td>
<td> model/id, callback </td>
<td> err </td>
<td> Appends a link to model in self. Restricts to a single item.</td>
<td></td>
</tr>
<tr>
<td></td>
<td> addBuddies </td>
<td> array, callback </td>
<td> err </td>
<td> Connects Models or ID’s connected in array with self</td>
<td></td>
</tr>
<tr>
<td></td>
<td> getBuddy </td>
<td> model/id, callback </td>
<td> err, model </td>
<td> Gets a linked model</td>
<td></td>
</tr>
<tr>
<td></td>
<td> getBuddies </td>
<td> array, callback </td>
<td> err, models </td>
<td> Retrieves the specified models (as long as a connection exists)</td>
<td></td>
</tr>
<tr>
<td></td>
<td> removeBuddy </td>
<td> model/id, callback </td>
<td> err </td>
<td> Unlinks the model from self. Restricts to a single item.</td>
<td></td>
</tr>
<tr>
<td></td>
<td> removeBuddies </td>
<td> array, callback </td>
<td> err </td>
<td> Breaks the relationsip with the specifeid models/ids (as long as a connection exists)</td>
<td></td>
</tr>
<tr>
<td></td>
<td> deepRemoveBuddy </td>
<td> model/id, callback </td>
<td> err </td>
<td> Breaks relationship with model and deletes the unlinked model from database. Restricts to a single item.</td>
<td></td>
</tr>
<tr>
<td></td>
<td> deepRemoveBuddies </td>
<td> array, callback </td>
<td> err </td>
<td> Breaks relationship with models and deletes the unlinked models from database.</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

Assuming _UsersModel_ set the relationship, the following example shows how to use the relationship:

    // we got buddy earlier
    
    app.model.getUser({name: 'ernie'}, function(err, user) {
      if (err) throw err;
      else user.addBuddy(buddy, function(err) {
         if (err) throw err;
         else console.exit("Buddy and User are now pals");
      });
    });

### belongsTo Relationship

This is an _Outbound_ relationship. Setting this relationship is exactly the same as setting a _hasOne_ relationship, but swapping
source and destination models. 

For example:

    // Relationship being set from UsersModel

    this.belongsTo = 'company.boss'
    
Assuming the relationship is being set by _UsersModel_, this would translate to:

    // Relationship as translated into CompaniesModel
    
    this.hasOne = 'boss(user)';
    
The same rules for _hasOne_ apply. You need to specify `{target-model}.{target-property}`. Both the _target model_ and _target property_
should be specified in _Singular Form_.

### belongsToMany Relationship

This is an _Outbound_ relationship. Setting this relationship is exactly the same as setting a _hasMany_ relationship, but swapping
the source and destination models.

For example:

    // Relationship as being set from UsersModel
    
    this.belongsToMany = 'company.employees'
    
Assuming the relationship is being set from _UsersModel_, this would translate to:

    // Relationship as translated into CompaniesModel
    
    this.hasMany = 'employees(users)';
    
The same rules for _hasMany_ apply. You need to specify `{target-model}.{target-property}`. The _target model_ is specified in 
_Singular Form_, and the _target property_ should be specified in _plural form_.


## Database Drivers

Drivers provide a set of methods to operate with the underlying database, as well as a _Model API Implementation_, which allows
the driver to be used with a Model.
  
Besides handling model internal operations, Drivers can be used by themselves. Here's how you get a _Driver Instance_ so you
can work with it:

    app.getResource('drivers/mongodb:users', function(driver) {
      console.exit(driver);
    });
    
You specify the _resource path_ to the Driver you want to use. Such driver uses the configuration specified in 
_config/database.js_. Driver instances are available via `app.drivers`.

Protos implements the following Drivers, which can be used to power Models:

- [MongoDB](https://github.com/derdesign/protos/blob/master/drivers/mongodb.js)
- [MySQL](https://github.com/derdesign/protos/blob/master/drivers/mysql.js)

If you're interested in contributing a new Database Driver, you're welcome to do so. You have a clean API to work with, so
it's pretty easy to implement new Database Drivers into the framework. Also, the source has been documented properly.
    
  
### Query Caching

You can attach a Storage into a Driver, which will be used as the underlying _Cache Storage_ for such driver.

The Storage you define in the Driver's configuration will be inherited by the Model that uses it.
  
To enable query caching in a driver, just specify the _Resource Path_ pointing to the storage you want to use
as the caching layer. This is done in the Database configuration, on _config/database.js_.

### Cache Keywords

The following extra properties can be specified to trigger cache operations:

- **cacheID** &nbsp; This will set the ID for the current cache. If the cache is not stored, the retrieved query will then be cached. 
Any subsequent queries will return the cached result. This will happen until the cache is _invalidated_.
- **cacheInvalidate** &nbsp; This will invalidate a cacheID, and will force any subsequent queries to regenerate the cache for the specified ID.
- **cacheTimeout** &nbsp; Amount of seconds in which the cacheID will be invalidated. The effect will be the same as cacheInvalidate. This only works if the storage
backend supports TTL Expiration.

This approach is both useful and interesting. Imagine you have a heavy query in your homepage, you need to retrieve 100 records in a 
rather expensive query. You can then cache the query using the ID `homepage_query`.

The cache will always be valid, _unless_ a new user is added. So, whenever you add a new user you need to _invalidate_ the `homepage_query`, so
the next time the homepage is accessed, the cache will be regenerated, this time accounting for the new user that has just been
created.

Internally, this all is done behind the scenes, and in a very organized way. You don't need to set any timeouts (even though you can), since
the cache will remain valid until something invalidates it.

### Cache storage

This example uses the [MongoDB](https://github.com/derdesign/protos/blob/master/drivers/mongodb.js) driver to cache the `homepage_query`:

    mongodb.queryAll({
      collection: 'users',
      fields: {'user': 1, 'pass': 1},
      cacheID: 'homepage_query',
    }, function(err, docs) {
      console.log([err, docs]);
    });
    
Any subsequent queries you perform with this cacheID, will return the cached content if it exists, otherwise it will query the 
records and cache the results into the `homepage_query` ID. This will happen until the cache is invalidated.

### Cache Invalidation

This example uses the [MongoDB](https://github.com/derdesign/protos/blob/master/drivers/mongodb.js) driver to invalidate the `homepage_query` cache:

    mongodb.insertInto({
      collection: 'users',
      values: {user: 'hello', pass: 'passme'},
      cacheInvalidate: 'homepage_query'
    }, function(err, docs) {
      console.log([err, docs]);
    });
    
This query will invalidate the `homepage_query` cache, and will force any subsequent requests to regenerate it.

## Storages API

Storages provide a common transport which can be used as a caching layer, or as a storage layer for the Application, 
Drivers and Models.

Storages are configured in _config/storage.js_. Here's how you get a storage:

    app.getResource('storages/redis:session', function(storage) {
      console.exit(storage);
    });
    
All storages implement a common API, that provide a layer of abstraction between two endpoints. The following table explains
the Storage API Methods:

<table>
<thead>
<tr>
<th></th>
<th> Method </th>
<th> Arguments&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </th>
<th> Provides&nbsp;&nbsp;&nbsp;&nbsp; </th>
<th> Description </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> get </td>
<td> key, callback </td>
<td> err, results </td>
<td> Retrieves one or more records from the storage backend (key accepts string/array)</td>
</tr>
<tr>
<td></td>
<td> getHash </td>
<td> key, callback </td>
<td> err, hash </td>
<td> Retrieves a hash from the storage backend</td>
</tr>
<tr>
<td></td>
<td> set </td>
<td> key, value, callback </td>
<td> err </td>
<td> Inserts one or more records into the storage backend. Key can also be an object with keys/values (skip value)</td>
</tr>
<tr>
<td></td>
<td> setHash </td>
<td> key, hash, callback </td>
<td> err </td>
<td> Inserts a hash (object) into the storage backend</td>
</tr>
<tr>
<td></td>
<td> updateHash </td>
<td>  key, object, callback </td>
<td> err </td>
<td> Updates a hash with new values in object</td>
</tr>
<tr>
<td></td>
<td> deleteFromHash </td>
<td> hash, key, callback </td>
<td> err  </td>
<td> Deletes one or more keys from a specific hash</td>
</tr>
<tr>
<td></td>
<td> delete </td>
<td> key, callback </td>
<td> err </td>
<td> Deletes one or more records from the storage backend</td>
</tr>
<tr>
<td></td>
<td> rename </td>
<td> oldkey, newkey </td>
<td> err </td>
<td> Renames a key</td>
</tr>
<tr>
<td></td>
<td> expire </td>
<td> key, timeout, callback </td>
<td> err  </td>
<td>  Makes a specific key expire in a certain amount of time (only on backends that support TTL)</td>
</tr>
<tr>
<td></td>
<td> multi </td>
<td> config </td>
<td> N/A </td>
<td> Allows execution of multiple storage operations</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

All the methods have the same effect, regardless of which storage backend you use. You are guaranteed to receive the same results.

### Available Storages

Protos provides the following Storages:

- [MongoDB](https://github.com/derdesign/protos/blob/master/storages/mongodb.js)
- [Redis](https://github.com/derdesign/protos/blob/master/storages/redis.js)

For more information about the Storage API, you can check out [its source](https://github.com/derdesign/protos/blob/master/lib/storage.js).

## Application & Framework Methods

Protos provides several methods in the Application Singleton that you can use right away in your applications. You can start 
using these with your applications. Full documentation can be found in the source code.

### Application API

For a list of the methods implemented in the application singleton, refer to the 
[application.js](https://github.com/derdesign/protos/blob/master/lib/application.js) source. 

### Protos API

To see the available methods provided by the framework's internals, refer to the sources in [lib/](https://github.com/derdesign/protos/tree/master/lib)

[/markdown]
